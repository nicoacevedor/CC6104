---
title: "Tarea 1"
output:
  html_document:
    df_print: paged
---

![](banner.png)

<center> <h1>Tarea 1: Foundations</h1> </center>
<center><strong>CC6104: Statistical Thinking</strong></center>
#### **Integrantes :** 

- Nicol√°s Acevedo Rivas
- Diego Navarrete Gonzalez

#### **Cuerpo Docente:**

- Profesor: Felipe Bravo M.
- Auxiliares: Mart√≠n Paredes, Mar√≠a Jos√© Zambrano
- Ayudantes: Nicolas Cabello, Kevin Iturra,  Mariana V√°squez

### **√çndice:**

1. [Objetivo](#id1)
2. [Instrucciones](#id2)
3. [Referencias](#id3)
4. [Segunda Parte: Elaboraci√≥n de C√≥digo](#id4)

### **Objetivo**<a name="id1"></a>

Bienvenid@s a la primera tarea del curso Statistical Thinking. Esta tarea tiene como objetivo evaluar los contenidos te√≥ricos de la primera parte del curso, los cuales se enfocan principalmente en an√°lisis exploratorio de datos y conceptos introductorios de probabilidades. Si a√∫n no han visto las clases, se recomienda visitar los enlaces de las referencias.

La tarea consta de ejercicios pr√°cticos con el f√≠n de introducirlos a la programaci√≥n en R enfocada en el an√°lisis estad√≠stico de datos. 

### **Instrucciones:**<a name="id2"></a>

- La tarea se realiza en grupos de **m√°ximo 2 personas**. Pero no existe problema si usted desea hacerla de forma individual.
- La entrega es a trav√©s de u-cursos a m√°s tardar el d√≠a estipulado en la misma plataforma. A las tareas atrasadas se les descontar√° un punto por d√≠a.
- El formato de entrega es este mismo **Rmarkdown** y un **html** con la tarea desarrollada. Por favor compruebe que todas las celdas han sido ejecutadas en el archivo html.
- Al momento de la revisi√≥n tu c√≥digo ser√° ejecutado. Por favor verifica que tu entrega no tenga errores de compilaci√≥n.
- No ser√°n revisadas tareas desarrolladas en Python.
- Est√° **PROHIBIDO** la copia o compartir las respuestas entre integrantes de diferentes grupos.
- Pueden realizar consultas de la tarea a trav√©s de U-cursos y/o del canal de Discord del curso. 


### **Referencias:**<a name="id3"></a>

Slides de las clases:

- [Introduction to Statistical Thinking](https://github.com/dccuchile/CC6104/blob/master/slides/1_1_ST-intro.pdf)
- [Introduction to R](https://github.com/dccuchile/CC6104/blob/master/slides/1_2_ST-R.pdf)
- [Descriptive Statistics](https://github.com/dccuchile/CC6104/blob/master/slides/1_3_ST-explore.pdf)
- [Probability](https://github.com/dccuchile/CC6104/blob/master/slides/1_4_ST-prob.pdf)

Videos de las clases:

- Introduction to Statistical Thinking: [video1](https://youtu.be/X4SqJu6lExM) [video2](https://youtu.be/YbiQU5TTBX4)
- Introduction to R: [video1](https://youtu.be/MbeLD3hWWVo) [video2](https://youtu.be/9W_eWCy86F4) [video3](https://youtu.be/QvFXSw2-1r4) [video4](https://youtu.be/y4JY7klrbfQ)
- Descriptive Statistics: [video1](https://youtu.be/kWNskZ8_98o) [video2](https://youtu.be/_FJ8x9M4b1w) [video3](https://youtu.be/m7VBNZ2mYWI) [video4](https://youtu.be/ylGMJ_aSQk0)
- Probability: [video1](https://youtu.be/R9AVYV73m1M) [video2](https://youtu.be/zubh1jbRiKE) [video3](https://youtu.be/uiwToagp0z4) [video4](https://youtu.be/RlhN3t_VIyw) [video5](https://youtu.be/4kV1dBaeWVc) [video6](https://youtu.be/MGyXc70JdSk)



En la siguiente secci√≥n deber√° resolver cada uno de los experimentos computacionales a trav√©s de la programaci√≥n en R. Para esto se le aconseja que cree funciones en R, ya que le facilitar√° la ejecuci√≥n de gran parte de lo solicitado.

## Pregunta 1: Visualizaci√≥n de Datos

Para esta pregunta usted deber√° trabajar en base al conjunto de datos `hearth_database.csv`, el cual esta compuesto por las siguientes variables:

- target: Se√±ala si el paciente tuvo un infarto.
- sex: Sexo de los sujetos de prueba.
- fbs: Az√∫car en la sangre con ayunas. Esta variable se√±ala solo si se encuentra <=120 o >120.
- exang: Angina de pecho inducida por el ejercicio.
- cp: Tipo de dolor de pecho.
- restecg: Resultados electrocardiogr√°ficos en reposo.
- slope: Pendiente del segmento ST m√°ximo de ejercicio.
- ca: N√∫mero de buques principales.
- thal: Thalassemia.
- age: Edad en a√±os.
- trestbps: Presi√≥n arterial en reposo.
- chol: colesterol s√©rico en mg/dl.
- thalach: Frecuencia card√≠aca m√°xima alcanzada.
- oldpeak: Depresi√≥n del ST inducida por el ejercicio en relaci√≥n con el reposo.

En base al dataset propuesto realice un an√°lisis exploratorio de los datos (EDA). Para su an√°lisis enfoquen el desarrollo en las siguientes tareas:

- [ ] Obtenga la media, mediana, quintiles y valores m√°ximos desde los datos que componen el dataset.
- [ ] Obtenga la Matriz de correlaci√≥n de Pearson y visualice la relaci√≥n entre las variables num√©ricas.
- [ ] Visualice los boxplot para las variables num√©ricas.
- [ ] Visualice a trav√©s de un histograma como distribuyen las variables respecto a los TARGET.

**Respuesta**
```{r}
my.frame <- read.table(file = "hearth_database.csv",header = T,sep = ",", fileEncoding = "latin1")
colnames(my.frame)[colnames(my.frame) == "√Ø..age"] <- "age"


#slope
mean(my.frame$slope)
median(my.frame$slope)
quantile(my.frame$slope)
max(my.frame$slope)

#ca
mean(my.frame$ca)
median(my.frame$ca)
quantile(my.frame$ca)
max(my.frame$ca)

#thal
mean(my.frame$thal)
median(my.frame$thal)
quantile(my.frame$thal)
max(my.frame$thal)

#age
mean(my.frame$age)
median(my.frame$age)
quantile(my.frame$age)
max(my.frame$age)

#trestbps
mean(my.frame$trestbps)
median(my.frame$trestbps)
quantile(my.frame$trestbps)
max(my.frame$trestbps)

#chol
mean(my.frame$chol)
median(my.frame$chol)
quantile(my.frame$chol)
max(my.frame$chol)

#thalach
mean(my.frame$thalach)
median(my.frame$thalach)
quantile(my.frame$thalach)
max(my.frame$thalach)

#oldpeak
mean(my.frame$oldpeak)
median(my.frame$oldpeak)
quantile(my.frame$oldpeak)
max(my.frame$oldpeak)


#summary(my.frame)
```


```{r}
cor(my.frame[,7:14])

```
```{r}
#boxplot(my.frame[,7:14],main="Hearth")
boxplot(my.frame$slope,main="Hearth slope")
boxplot(my.frame$ca,main="Hearth ca")
boxplot(my.frame$thal,main="Hearth thal")
boxplot(my.frame$age,main="Hearth age")
boxplot(my.frame$trestbps,main="Hearth trestbps")
boxplot(my.frame$chol,main="Hearth chol")
boxplot(my.frame$thalach,main="Hearth thalach")
boxplot(my.frame$oldpeak,main="Hearth oldpeak")

```
```{r}
hist(my.frame$age[my.frame$target == "YES"],main="Distribuci√≥n de Edad para 'YES'")
hist(my.frame$age[my.frame$target == "NO"],main="Distribuci√≥n de Edad para 'NO'")

hist(my.frame$slope[my.frame$target == "YES"],main="Distribuci√≥n de slope para 'YES'")
hist(my.frame$slope[my.frame$target == "NO"],main="Distribuci√≥n de slope para 'NO'")

hist(my.frame$ca[my.frame$target == "YES"],main="Distribuci√≥n de ca para 'YES'")
hist(my.frame$ca[my.frame$target == "NO"],main="Distribuci√≥n de ca para 'NO'")

hist(my.frame$thal[my.frame$target == "YES"],main="Distribuci√≥n de thal para 'YES'")
hist(my.frame$thal[my.frame$target == "NO"],main="Distribuci√≥n de thal para 'NO'")

hist(my.frame$trestbps[my.frame$target == "YES"],main="Distribuci√≥n de trestbps para 'YES'")
hist(my.frame$trestbps[my.frame$target == "NO"],main="Distribuci√≥n de trestbps para 'NO'")

hist(my.frame$chol[my.frame$target == "YES"],main="Distribuci√≥n de chol para 'YES'")
hist(my.frame$chol[my.frame$target == "NO"],main="Distribuci√≥n de chol para 'NO'")

hist(my.frame$thalach[my.frame$target == "YES"],main="Distribuci√≥n de thalach para 'YES'")
hist(my.frame$thalach[my.frame$target == "NO"],main="Distribuci√≥n de thalach para 'NO'")

hist(my.frame$oldpeak[my.frame$target == "YES"],main="Distribuci√≥n de oldpeak para 'YES'")
hist(my.frame$oldpeak[my.frame$target == "NO"],main="Distribuci√≥n de oldpeak para 'NO'")

```


---

## Pregunta 2: Teorema Central del Limite

Pruebe el teorema central del limite aplicando un muestreo de la media en las distribuciones Gamma, Normal y una a su elecci√≥n. Grafique los resultados obtenidos y se√±ale aproximadamente el numero de muestreos necesarios para obtener el resultado esperado, pruebe esto con las siguientes cantidades de muestreo $\{10,100,1000,5000\}$. ¬øEl efecto ocurre con el mismo n√∫mero de muestreo para todas las distribuciones?.

**Respuesta**

```{r}
# Definici√≥n de variables o estructuras necesarias para el muestreo.
# Primero definimos la funci√≥n plot_gauss, que nos permitir√° graficar r√°pidamente.
plot_gauss <- function(x, name) {
  avg <- mean(x)
  std <- sd(x)
  x_axis <- seq(min(x), max(x), length = length(x))
  y_axis <- dnorm(x_axis, mean = avg, sd = std)
  hist(x, main = sprintf("Gr√°fico de la distribuci√≥n %s", name))
  lines(x_axis, y_axis, type = "l", col = "red")
}

# Representamos las distribuciones Normal, Gamma y de Poisson, de par√°metros N(1.5, 0.75), G(2, 1.5) y P(5).
avg <- 1.5
std <- 0.75
shape <- 2
scale <- 1.5
lambda <- 5

# Inicializamos los vectores que acumular√°n las medias para cada muestreo.
iter <- 1000
normal_vector <- vector(length = iter)
gamma_vector <- vector(length = iter)
poisson_vector <- vector(length = iter)
```

```{r fig.width=12}
# Graficamos las 3 distribuciones para distintos tama√±os de la muestra
sample_size <- 10

# Realizar el muestreo de las distribuciones.
for(i in 1:iter) {
  new_vector <- rnorm(n = sample_size, mean = avg, sd = std)
  normal_vector[i] <- mean(new_vector)
  
  new_vector <- rgamma(n = sample_size, shape = shape, scale = scale)
  gamma_vector[i] <- mean(new_vector)

  new_vector <- rpois(n = sample_size, lambda = lambda)
  poisson_vector[i] <- mean(new_vector)
}

# C√≥digo para gr√°ficos
par(mfrow = c(1, 3))
plot_gauss(normal_vector, sprintf("Normal con tama√±o %s", sample_size))
plot_gauss(gamma_vector, sprintf("Gamma con tama√±o %s", sample_size))
plot_gauss(poisson_vector, sprintf("de Poisson con tama√±o %s", sample_size))
```

```{r fig.width=12}
# Graficamos las 3 distribuciones para distintos tama√±os de la muestra
sample_size <- 100

# Realizar el muestreo de las distribuciones.
for(i in 1:iter) {
  new_vector <- rnorm(n = sample_size, mean = avg, sd = std)
  normal_vector[i] <- mean(new_vector)
  
  new_vector <- rgamma(n = sample_size, shape = shape, scale = scale)
  gamma_vector[i] <- mean(new_vector)

  new_vector <- rpois(n = sample_size, lambda = lambda)
  poisson_vector[i] <- mean(new_vector)
}

# C√≥digo para gr√°ficos
par(mfrow = c(1, 3))
plot_gauss(normal_vector, sprintf("Normal con tama√±o %s", sample_size))
plot_gauss(gamma_vector, sprintf("Gamma con tama√±o %s", sample_size))
plot_gauss(poisson_vector, sprintf("de Poisson con tama√±o %s", sample_size))
```

```{r fig.width=12}
# Graficamos las 3 distribuciones para distintos tama√±os de la muestra
sample_size <- 1000

# Realizar el muestreo de las distribuciones.
for(i in 1:iter) {
  new_vector <- rnorm(n = sample_size, mean = avg, sd = std)
  normal_vector[i] <- mean(new_vector)
  
  new_vector <- rgamma(n = sample_size, shape = shape, scale = scale)
  gamma_vector[i] <- mean(new_vector)

  new_vector <- rpois(n = sample_size, lambda = lambda)
  poisson_vector[i] <- mean(new_vector)
}

# C√≥digo para gr√°ficos
par(mfrow = c(1, 3))
plot_gauss(normal_vector, sprintf("Normal con tama√±o %s", sample_size))
plot_gauss(gamma_vector, sprintf("Gamma con tama√±o %s", sample_size))
plot_gauss(poisson_vector, sprintf("de Poisson con tama√±o %s", sample_size))
```

```{r fig.width=12}
# Graficamos las 3 distribuciones para distintos tama√±os de la muestra
sample_size <- 5000

# Realizar el muestreo de las distribuciones.
for(i in 1:iter) {
  new_vector <- rnorm(n = sample_size, mean = avg, sd = std)
  normal_vector[i] <- mean(new_vector)
  
  new_vector <- rgamma(n = sample_size, shape = shape, scale = scale)
  gamma_vector[i] <- mean(new_vector)

  new_vector <- rpois(n = sample_size, lambda = lambda)
  poisson_vector[i] <- mean(new_vector)
}

# C√≥digo para gr√°ficos
par(mfrow = c(1, 3))
plot_gauss(normal_vector, sprintf("Normal con tama√±o %s", sample_size))
plot_gauss(gamma_vector, sprintf("Gamma con tama√±o %s", sample_size))
plot_gauss(poisson_vector, sprintf("de Poisson con tama√±o %s", sample_size))
```

Notemos que para la distribuci√≥n de Poisson, los datos convergen a una distribuci√≥n Normal al realizar muestreos de tama√±o 100, mientras que las otras dos a√∫n no muestran ese comportamiento. Es al tama√±o de muestra de 1000 que las 3 distribuciones se comportan como uno esperar√≠a te√≥ricamente.
---

## Pregunta 3: Ley de los Grandes Numeros.

#### Lanzamiento de monedas
Realice el experimento de lanzar una moneda cargada 1000 veces y observe el comportamiento que tiene la probabilidad de salir cara. Para realizar el experimento considere que la moneda tiene una probabilidad de $5/8$ de salir cara. Grafique el experimento para las secuencias de intentos que van desde 1 a 1000, se√±alando el valor en que converge la probabilidad de salir cara.

**Respuesta**

```{r}


# Inicializa un vector para almacenar las probabilidades en cada paso
probabilidades <- numeric(1000)

# Simular lanzamientos
for (lanzamientos in 1:1000) {
  # Genera una secuencia de lanzamientos de la moneda y cuenta cu√°ntas caras salieron
  resultados <- sample(c("cara", "sello"), lanzamientos, replace = TRUE, prob = c(5/8, 1 - 5/8))
  caras <- sum(resultados == "cara")
  
  # Calcula la probabilidad de salir cara en este punto
  probabilidad_actual <- caras / lanzamientos
  probabilidades[lanzamientos] <- probabilidad_actual
}

# Gr√°fico de la convergencia

plot(1:1000, probabilidades, type = "l", col = "blue", xlab = "N√∫mero de intentos", ylab = "Probabilidad de salir cara")
abline(h = 5/8, col = "red", lty = 2)
legend("topright", legend = c("Probabilidad te√≥rica", "Probabilidad simulada"), col = c("red", "blue"), lty = 2:1)
```

#### El problema de Monty Hall 

Remont√°ndonos en la televisi√≥n del a√±o 1963, en USA exist√≠a un programa de concursos donde los participantes deb√≠an escoger entre 3 puertas para ganar un premio so√±ado. El problema del concurso era que solo detr√°s de 1 puerta estaba el premio mayor, mientras que detr√°s de las otras dos hab√≠an cabras como "premio". 

Una de las particularidades de este concurso, es que cuando el participante escog√≠a una puerta, el animador del show abr√≠a una de las puertas que no fue escogida por el participante (Obviamente la puerta abierta por el animador no conten√≠a el premio). Tras abrir la puerta, el animador consultaba al participante si su elecci√≥n era definitiva, o si deseaba cambiar la puerta escogida por la otra puerta cerrada. Un v√≠deo que puede ayudar a comprender mejor este problema en el siguiente [link](https://www.youtube.com/watch?v=rSa_uiKncEI).

Imagine que usted es participante del concurso y desea calcular la probabilidad de ganar el gran premio **si cambia de puerta** en el momento que el animador se lo ofrece. Utilizando listas/arrays/vectores simule las puertas del concurso, dejando aleatoriamente el premio en alguna posici√≥n del array. Hecho esto, genere un numero de forma aleatoria para escoger una de las puerta (posiciones de la estructura), para luego ver si cambiando de posici√≥n tendr√° mayores posibilidades de ganar el premio. Genere N veces el experimento y grafique cada una de las iteraciones, tal como se hizo en el ejercicio de las monedas.

<p align="center">
  <img src="https://brilliant-staff-media.s3-us-west-2.amazonaws.com/tiffany-wang/gWotbuEdYC.png" width="350">
</p>


**Respuesta:**

```{r}
# Creamos una funci√≥n que simule el juego
montyhall <- function(cambiar = TRUE){
  puertas <- sample(1:3,3)             #Puertas donde la posici√≥n que tiene el 3 es el premio
  eleccion <- sample(1:3,1)            #Elecci√≥n del participante.

  puertas_no_elegidas <- setdiff(puertas, eleccion)

  puertas_no_elegidas_corr <-puertas_no_elegidas[puertas_no_elegidas != 3]
  if(length(puertas_no_elegidas_corr) == 1){
    puerta_abierta <- puertas_no_elegidas[1]
  }
  else{
    puerta_abierta <- sample(puertas_no_elegidas[puertas_no_elegidas != 3], size = 1)
  }
  


  eleccion_final <- eleccion == 3
  if(cambiar){

    puertas_restantes <- setdiff(puertas, c(eleccion, puerta_abierta))

    eleccion_final <- puertas_restantes
    eleccion_final <- puertas[eleccion_final] == 3
  }
  
  return(eleccion_final) # Retornamos la elecci√≥n, esta puede que tenga el premio o no
}

# Funci√≥n que simula N juegos
n_juegos <- function(n = 10 ,cambiar_puerta = TRUE){
  resultados <- replicate(n, montyhall(cambiar_puerta))
  
  probabilidad_cambio <- mean(resultados)
  
  plot(1:n, cumsum(resultados)/(1:n), type = "l", col = "blue", 
     xlab = "N√∫mero de simulaciones", ylab = "Probabilidad de ganar ")
abline(h = probabilidad_cambio, col = "red", lty = 2)
legend("topright", legend = c("Probabilidad", "Probabilidad promedio"), col = c("red", "blue"), lty = 2:1)
  

}
n_juegos(1000)
n_juegos(1000,FALSE)
```

---

## Pregunta 4: ¬øIndependencia?
Ustedes disponen de los dados D1 y D2, los cuales no est√°n cargados y son utilizados para comprobar que $\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)$ cuando el evento A es independiente del B. Para estudiar la independencia considere que los eventos A y B se definen de la siguiente manera; sea A el evento dado por los valores obtenidos en el lanzamiento del dado D1, este est√° compuesto por $A=\{D1=1,D1=2,D1=6\}$. Por otro lado, el evento B viene dado por los valores obtenidos con el dado D2, el que est√° conformado por $B=\{D2=1,D2=2,D2=3,D2=4\}$. Con esto, tendremos un $\mathbb{P}(A)=1/2$, $\mathbb{P}(ùêµ)=2/3$ y $\mathbb{P}(AB)=1/3$. Compruebe de forma gr√°fica que al realizar 1000 lanzamientos (u otro valor grande que usted desea probar) se visualiza que $\mathbb{P}(AB)=\mathbb{P}(A)\mathbb{P}(B)$. 

Hecho lo anterior, compruebe el comportamiento de un segundo grupo de eventos, dados por el lanzamiento de solo el dado D1. Donde, los eventos para D1 quedan definidos como: $A =\{D1=1,D1=2,D1=6\}$ y $B=\{D1=1,D1=2,D1=3\}$. ¬øSe observa independencia en este experimento?.

Se le aconseja que para simular los lanzamientos de dados utilice la funci√≥n `sample()` para generar valores aleatorios entre 1 y 6. Compruebe los n√∫meros generados por la funci√≥n con los casos favorables de cada uno de los eventos a ser estudiados.

**Respuesta:**

```{r}
n_lan <- 6000000

# Primer grupo de eventos
dice1 <- sample(1:6, n_lan, replace = TRUE)  # Dado 1
dice2 <- sample(1:6, n_lan, replace = TRUE)  # Dado 2
dice_count1 <- table(dice1)
dice_count2 <- table(dice2)

favorable_a <- c(1, 2, 6)  # {1, 2, 6}
favorable_b <- c(1, 2, 3, 4)  # {1, 2, 3, 4}
favorable_ayb <- c(1, 2)  # {1, 2}

count_a <- sum(dice_count1[favorable_a])  # |A|
count_b <- sum(dice_count2[favorable_b])  # |B|

# Ahora contamos los casos donde A y B se cumplen al mismo tiempo
count_ayb <- 0  # |A‚à©B|
for (i in 1:n_lan) {
  if (dice1[i] %in% favorable_a && dice2[i] %in% favorable_b) {
    count_ayb <- count_ayb + 1
  }
}

# Calculamos las probabilidades
prob_a <- count_a / n_lan  # P(A)
prob_b <- count_b / n_lan  # P(B)
prob_ayb <- count_ayb / n_lan  # P(A‚à©B)

print(sprintf("P(A) = %s", prob_a))
print(sprintf("P(B) = %s", prob_b))
print(sprintf("P(A)*P(B) = %s", prob_a*prob_b))
print(sprintf("P(A‚à©B) = %s", prob_ayb))
```


Ahora visualizamos las probabilidades
```{r, fig.width=12, fig.height=6}
par(mfrow = c(1, 2))
y_ax <- c(0, 0, 1, 1)
x_ax <- c(0, 1, 1, 0)

# Graficamos P(A)
plot(1, ann = FALSE, type = "n", axes = FALSE, xlim = c(0, 1), ylim = c(0, 1), main = "P(A)")
x_p_a <- c(0, prob_a, prob_a, 0)
x_p_a_c <- c(prob_a, 1, 1, prob_a)

polygon(x_p_a, y_ax, col = "blue")
text(mean(x_p_a), mean(y_ax), expression(P(A)), col = "white", cex = 1.5)

polygon(x_p_a_c, y_ax, col = "red")
text(mean(x_p_a_c), mean(y_ax), expression(P(A^c)), col = "white", cex = 1.5)


# Graficamos P(B)
plot(2, ann = FALSE, type = "n", axes = FALSE, xlim = c(0, 1), ylim = c(0, 1), main = "P(B)")
y_p_b <- c(prob_b, prob_b, 1, 1)
y_p_b_c <- c(0, 0, prob_b, prob_b)

polygon(x_ax, y_p_b, col = "blue")
text(mean(x_ax), mean(y_p_b), expression(P(B)), col = "white", cex = 1.5)

polygon(x_ax, y_p_b_c, col = "red")
text(mean(x_ax), mean(y_p_b_c), expression(P(B^c)), col = "white", cex = 1.5)
```

Ahora grafiquemos $\mathbb{P}(AB)$

```{r, fig.width=6, fig.height=6}
plot(1, ann = FALSE, type = "n", axes = FALSE, xlim = c(0, 1), ylim = c(0, 1), main = "P(A‚à©B)")

polygon(c(0, prob_a, prob_a, 0), c(prob_b, prob_b, 1, 1), col = "blue")
text(prob_a / 2, 1 - prob_b / 4, expression(P(A * "‚à©" * B)), col = "white", cex = 1.5)

polygon(c(0, prob_a, prob_a, 0), c(0, 0, prob_b, prob_b), col = "purple")
text(prob_a / 2, prob_b / 2, expression(P(A * "‚à©" * B^c)), col = "white", cex = 1.5)

polygon(c(prob_a, 1, 1, prob_a), c(prob_b, prob_b, 1, 1), col = "purple")
text(1 - prob_a / 2, 1 - prob_b / 4, expression(P(A^c * "‚à©" * B)), col = "white", cex = 1.5)

polygon(c(prob_a, 1, 1, prob_a), c(0, 0, prob_b, prob_b), col = "red")
text(1 - prob_a / 2, prob_b / 2, expression(P(A^c * "‚à©" * B^c)), col = "white", cex = 1.5)
```

Notemos que el √°rea del cuadrado de la esquina superior izquierda, que representa el √°rea de $\mathbb{P}(A \cap B)$, tiene la misma √°rea que la superposici√≥n de las figuras anteriores, 

---
## Pregunta 5: La Ruina del Jugador
Un amigo lud√≥pata suyo le comenta que el truco de jugar en el casino esta en no parar de apostar y apostando lo m√≠nimo posible. Ya que as√≠, tienes mas probabilidades de ganar el gran pozo que acumula el juego. Usted sabiendo la condici√≥n de su amigo, decide no creer en su conjetura y decide probar esto a trav√©s de un experimento.

Para realizar el experimento usted decide asumir las siguientes declaraciones, bajo sus observaciones:

- La probabilidad de ganar en un juego del casino es $8/19$
- Sabe que su amigo *solo* posee siempre fondos en el rango de 0 a 200 dolares.
- Las apuestas como m√≠nimo deben ser igual a 5 dolares.
- El monto de las apuestas no cambia y son siempre igual a la primera. Por ejemplo, si su amigo apuesta 50 dolares, todos los pr√≥ximos juegos apuesta 50 hasta que se acaba su dinero.
- Usted pierde cuando se le acaban los fondos.

En el primer experimento deber√° obtener la evoluci√≥n de los fondos hasta que el jugador se queda sin fondos para jugar. Puede ser √∫til seguir la l√≥gica de una moneda cargada para realizar esto. Pruebe esto con una apuesta igual a 5, 25 y 50 graficando los resultados. Comente los resultados obtenidos.

Para la segunda parte de este experimento, con las funciones ya creadas, proyecte 5000 apuestas y obtenga la probabilidad a la que converge el experimento empezando con una apuesta de: 5, 25 y 50. Para este experimento considerar como √©xito (1) cuando su funci√≥n ruina supera los 200 y considere lo contrario cuando su funci√≥n perdida es menor o igual a 0.


**Respuesta**

```{r}
# Funci√≥n para obtener el desarrollo de las apuestas
ruina <- function(money = 100, bet = 5) {
  vec_money <- c(money)
  while (0 < money && money < 200) {
    game <- as.integer(runif(1, 1, 19))
    sign <- if (game <= 8) 1 else -1
    money <- money + sign * bet
    vec_money <- append(vec_money, money)
  }
  return(vec_money)
}

plot(ruina(), type="l", col="blue", xlab="N¬∞ de juegos", ylab="Fondos", main="Evoluci√≥n de los fondos (apuesta = 5)")
plot(ruina(bet = 25), type="l", col="blue", xlab="N¬∞ de juegos", ylab="Fondos", main="Evoluci√≥n de los fondos (apuesta = 25)")
plot(ruina(bet = 50), type="l", col="blue", xlab="N¬∞ de juegos", ylab="Fondos", main="Evoluci√≥n de los fondos (apuesta = 50)")
```

En general se ve que la tendencia es perder, solo que al apostar el m√≠nimo se pierde m√°s lento ya que al ser una variaci√≥n m√°s peque√±a, se desestabiliza (es decir, se va a los extremos) de a poco, no as√≠ al apostar 50, que es posible perder en dos juegos.

```{r}
n_bet <- 5000
bet5_vector <- vector(length = n_bet)
bet20_vector <- vector(length = n_bet)
bet50_vector <- vector(length = n_bet)
for (i in 1:n_bet) {
  final5_money <- tail(ruina(bet = 5), 1)
  final20_money <- tail(ruina(bet = 20), 1)
  final50_money <- tail(ruina(bet = 50), 1)
  win5 <- if (final5_money <= 0) 0 else 1
  win20 <- if (final20_money <= 0) 0 else 1
  win50 <- if (final50_money <= 0) 0 else 1
  bet5_vector[i] <- win5
  bet20_vector[i] <- win20
  bet50_vector[i] <- win50
}
t5 <- table(bet5_vector)
t20 <- table(bet20_vector)
t50 <- table(bet50_vector)
print(sprintf("Apuesta = 5 -> E = %d, F = %d, Prob = %f", t5["1"], t5["0"], t5["1"]/(t5["1"] + t5["0"])))
hist(bet5_vector, main = sprintf("√âxitos y fracasos para apuesta = 5"))
print(sprintf("Apuesta = 20 -> E = %d, F = %d, Prob = %f", t20["1"], t20["0"], t20["1"]/(t20["1"] + t20["0"])))
hist(bet20_vector, main = sprintf("√âxitos y fracasos para apuesta = 20"))
print(sprintf("Apuesta = 50 -> E = %d, F = %d, Prob = %f", t50["1"], t50["0"], t50["1"]/(t50["1"] + t50["0"])))
hist(bet50_vector, main = sprintf("√âxitos y fracasos para apuesta = 50"))
```

Puede verse que la probabilidad de √©xito va aumentando a medida que el monto de apuesta aumenta. 


&nbsp;
<hr />
<p style="text-align: center;">A work by <a href="https://github.com/dccuchile/CC6104">CC6104</a></p>

<!-- Add icon library -->
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.1/css/all.css">

<!-- Add font awesome icons -->
<p style="text-align: center;">
    <a href="https://github.com/dccuchile/CC6104"><i class="fab fa-github" style='font-size:30px'></i></a>
</p>

&nbsp;